<!DOCTYPE HTML>
<html>
<head>

	<style>
		html, body{
			margin: 0;
			padding: 0;

			color: #999;
			background-color: #111;

			font-family: monospace;
			font-size: 12px;
		}

		#W {
			width: 900px;
			height: 900px;

			margin: 20px auto;
			position: relative;

			border: 1px dashed #999;

			overflow: hidden;
		}

		.box {
			width: 20px;
			height: 20px;
			border: 1px solid #999;

			position: absolute;

			box-sizing: border-box;
		}

	</style>

	<script language = "javascript" src = "numeric.js"></script>
	<script language = "javascript" src = "jquery-2.1.4.min.js"></script>

	<script language = "javascript">
		var disjoint = function(){
			this.parentOf = [];
		}

		disjoint.prototype.find = function(x){
			if (this.parentOf[x] == x){ return x; }
			else { this.parentOf[x] = this.find(this.parentOf[x]); return this.parentOf[x]; } 
		}

		disjoint.prototype.unite = function(a, b){
			var A = this.find(a);
			var B = this.find(b);

			if(A == B) return;

			this.parentOf[B] = A;
		}
	</script>

	<script language = "javascript">

		var E = {
			w: function(){ return $('#W').width(); },
			h: function(){ return $('#W').height(); },
			offsetX: function(){ return $('#W').offset().left },
			offsetY: function(){ return $('#W').offset().top }
		};
		function globalq(q){ return ([q[0]-E.offsetX(), E.w()-q[1]+E.offsetY()]); }


		var dt = 0.1;
		var g = [0, -9.8, 0];


		//collision groups
		var collision_groups = new disjoint;
		function connect(A, B){ collision_groups.unite(A.i, B.i); }



		var box = function(i, m, w, h, q, v){
			this.i = i; //index

			collision_groups.parentOf[i] = i; //collision group

			this.invm = 1/m;
			this.invI = 12/(m*(h*h+w*w));

			this.w = w;	//width
			this.h = h;	//height

			this.q = q; //position
			this.qprev = numeric['-'](q, numeric['*'](v, dt)); //prev position

			this.render(); this.sync();
		}

		box.prototype.render = function(){

			S = '<div id = "B' + this.i + '" class = "box" style = "' +
			'width:' + this.w + 'px; height:' + this.h + 'px;' +
			'left:' + (-this.w/2) + 'px;' +
			'bottom:' + (-this.h/2) + 'px;' +
			'"></div>';

			$('#W').append(S); this.elem = $('#B' + this.i);
		}

		box.prototype.sync = function(){
			this.elem.css({
				'-webkit-transform' : 'translate('
				+ this.q[0] + 'px, '
				+ (-this.q[1]) + 'px) rotate('
				+ (-this.q[2]) + 'rad)'
			});
		}


		//debugg marking function
		var marklabel = 0;
		function mark(q){

			S = '<div id = "mark' + marklabel + '" style = "' +
			'position: absolute; width: 4px; height: 4px; background-color: #fff;' +
			'left: -2px;' +
			'bottom: -2px;' +
			'">' + marklabel + '</div>';

			$('#W').append(S);
			var elem = $('#mark' + marklabel);

			elem.css({
				'-webkit-transform' : 'translate('
				+ q[0] + 'px, '
				+ (-q[1]) + 'px)'
			});
			marklabel++;
		}



		//constraint general
		var constraint = function(i, S){
			this.i = i;	//index
			this.S = S; //member bodies

			/*
			this.W = [];

			for(var i = 0; i < 3*this.S.length; ++i){ this.W[i] = [];
			for(var j = 0; j < 3*this.S.length; ++j){
				this.W[i][j] = 0;
			}}

			for(var i = 0; i < S.length; ++i){
				this.W[3*i][3*i] = S[i].invm;
				this.W[3*i+1][3*i+1] = S[i].invm;
				this.W[3*i+2][3*i+2] = S[i].invI;
			}
			*/
		}
		constraint.prototype.condition = function(){ return true; }
		constraint.prototype.C = function() { return 0;	}
		constraint.prototype.nablaC = function() {

			var nablaC = [];

			var C0 = this.C();
			var epsilon = 1e-6;
			for(var i = 0; i < this.S.length; ++i){
				this.S[i].q[0] += epsilon; nablaC[3*i] = (this.C()-C0)/epsilon; this.S[i].q[0] -= epsilon;
				this.S[i].q[1] += epsilon; nablaC[3*i+1] = (this.C()-C0)/epsilon; this.S[i].q[1] -= epsilon;
				this.S[i].q[2] += epsilon; nablaC[3*i+2] = (this.C()-C0)/epsilon; this.S[i].q[2] -= epsilon;
			}

			return [nablaC];
		}
		constraint.prototype.solve = function(){

			if(this.condition()){
				var nablaC = this.nablaC();
				//var nablaCT = numeric['transpose'](nablaC);
				//var WnablaCT = numeric['dot'](this.W, nablaCT);

				var WnablaCT = [];
				for(var i = 0; i < this.S.length; ++i){
					WnablaCT[3*i] = [nablaC[0][3*i]*this.S[i].invm];
					WnablaCT[3*i+1] = [nablaC[0][3*i+1]*this.S[i].invm];
					WnablaCT[3*i+2] = [nablaC[0][3*i+2]*this.S[i].invI];
				}
				
				var nablaCWnablaCT =
				numeric['dot'](nablaC, WnablaCT);
				
				if(numeric['det'](nablaCWnablaCT) == 0){ return; }

				var lambda = numeric['*'](-this.C(), numeric['inv'](nablaCWnablaCT));
				/*
				numeric['*'](
					numeric['inv'](nablaCWnablaCT), numeric['*'](-1, this.C())
				);
				*/

				var dP = numeric['dot'](WnablaCT, lambda);
				//update positions
				for(var i = 0; i < this.S.length; ++i){
					this.S[i].q = numeric['+'](this.S[i].q, [dP[3*i][0], dP[3*i+1][0], dP[3*i+2][0]]);
				}
			}
		}



		//vector rotation (element form)
		function rot(th, v){
		return ([v[0]*Math.cos(th) - v[1]*Math.sin(th),	v[0]*Math.sin(th) + v[1]*Math.cos(th)]);
		}
		function X(u, v){ return (u[0]*v[1] - u[1]*v[0]); }
		//vector length squared (not used)
		//function L2(v){ return v[0]*v[0]+v[1]*v[1]; }

		//constraint: rev constraint
		function rev_constraint(i, A, B, P){
			constraint.call(this, i, [A, B]);

			connect(this.S[0], this.S[1]); //rev constraint connects bodies.

			this.rA = numeric['-'](P, [this.S[0].q[0], this.S[0].q[1]]);
			this.rA = rot(-this.S[0].q[2], this.rA);

			this.rB = numeric['-'](P, [this.S[1].q[0], this.S[1].q[1]]);
			this.rB = rot(-this.S[1].q[2], this.rB);
		}
		rev_constraint.prototype = Object.create(constraint.prototype);
		rev_constraint.prototype.constructor = rev_constraint;

		rev_constraint.prototype.C = function(){
			var D = numeric['-'](
				numeric['+'](
					[this.S[0].q[0], this.S[0].q[1]],
					rot(this.S[0].q[2], this.rA)
				),
				numeric['+'](
					[this.S[1].q[0], this.S[1].q[1]],
					rot(this.S[1].q[2], this.rB)
				)
			);

			return numeric['dot'](D, D);
		}



		//constraint: dist constraint
		function dist_constraint(i, A, B, PA, PB){
			constraint.call(this, i, [A, B]);

			this.rA = numeric['-'](PA, [this.S[0].q[0], this.S[0].q[1]]);
			this.rA = rot(-this.S[0].q[2], this.rA);

			this.rB = numeric['-'](PB, [this.S[1].q[0], this.S[1].q[1]]);
			this.rB = rot(-this.S[1].q[2], this.rB);

			this.d = numeric['-'](PB, PA);
			this.d = numeric['dot'](this.d, this.d);
		}
		dist_constraint.prototype = Object.create(constraint.prototype);
		dist_constraint.prototype.constructor = dist_constraint;

		dist_constraint.prototype.D = function(){
			var D = numeric['-'](
				numeric['+'](
					[this.S[0].q[0], this.S[0].q[1]],
					rot(this.S[0].q[2], this.rA)
				),
				numeric['+'](
					[this.S[1].q[0], this.S[1].q[1]],
					rot(this.S[1].q[2], this.rB)
				)
			);
			return numeric['dot'](D, D);
		}
		dist_constraint.prototype.C = function(){
			var D = this.D();

			return D - this.d;
		}


		//constraint: anchor constraint
		function anchor_constraint(i, A){
			constraint.call(this, i, [A]);

			this.P = this.S[0].q;
		}
		anchor_constraint.prototype = Object.create(constraint.prototype);
		anchor_constraint.prototype.constructor = anchor_constraint;

		anchor_constraint.prototype.solve = function(){ this.S[0].q = this.P; }


		//constraint: collision constraint
		function k_constraint(i, A, B, data){
			constraint.call(this, i, [A, B]);

			this.data = data;

			if(data['inc'] == 0){
				this.rA = this.data['Rinc'];
				this.rB = this.data['Rref'];
			} else {
				this.rA = this.data['Rref'];
				this.rB = this.data['Rinc'];
			}

		}
		k_constraint.prototype = Object.create(constraint.prototype);
		k_constraint.prototype.constructor = k_constraint;

		k_constraint.prototype.condition = function(){ return this.C() > 0; }

		k_constraint.prototype.C = function(){
			var rA = rot(this.S[0].q[2], this.rA);
			var rB = rot(this.S[1].q[2], this.rB);

			return numeric['dot'](
			numeric['-'](
				[this.S[0].q[0]+rA[0], this.S[0].q[1]+rA[1]],
				[this.S[1].q[0]+rB[0], this.S[1].q[1]+rB[1]]
			), this.data['n']);
		}



		//collision detection
		function box_to_box(A, B){
			//Separate Axis Thm.
			
			var diagA1 = rot(A.q[2], [A.w/2, A.h/2]);
			var diagA2 = rot(A.q[2], [A.w/2, -A.h/2]);

			var diagB1 = rot(B.q[2], [B.w/2, B.h/2]);
			var diagB2 = rot(B.q[2], [B.w/2, -B.h/2]);

			var d = [B.q[0]-A.q[0], B.q[1]-A.q[1]];

			var axes = [
				rot(A.q[2], [1, 0]),
				rot(A.q[2], [0, 1]),
				rot(B.q[2], [1, 0]),
				rot(B.q[2], [0, 1]),
			];

			var tmp = [];

			tmp['i'] = 0; tmp['n'] = axes[0]; tmp['dL'] = 1e+9;

			for(var i = 0; i < 4; ++i){

				var projA = Math.max(
					Math.abs(numeric['dot'](diagA1, axes[i])),
					Math.abs(numeric['dot'](diagA2, axes[i]))
				);

				var projB = Math.max(
					Math.abs(numeric['dot'](diagB1, axes[i])),
					Math.abs(numeric['dot'](diagB2, axes[i]))
				);

				var projD = Math.abs(numeric['dot'](d, axes[i]));

				var e = projA + projB - projD;
				if(e < 0){ return false; }
				if(e < tmp['dL']){

					tmp['i'] = i;
					tmp['n'] = axes[i];
					tmp['dL'] = e;

					var sign = 1;
					if(numeric['dot'](d, tmp['n']) < 0){ tmp['n'] = numeric['*'](tmp['n'], -1); }
				}
			}

			//call contact generation
			var res = generate_contacts(A, B, tmp);

			return res;
		}
		
		//generate contact points from manifold an colliding shapes.
		function generate_contacts(A, B, manifold){

			var S = [A, B];

			//find best colliding edges.
			var edge = [];
			var enormals = [];
			var vertices = [];

			var ref = 0; var inc = 0; var prodref = 0;

			var N = [];

			for(var k = 0; k < 2; ++k){

				enormals[k] = [
					rot(S[k].q[2], [1, 0]),
					rot(S[k].q[2], [0, 1]),
					rot(S[k].q[2], [-1, 0]),
					rot(S[k].q[2], [0, -1])
				];

				vertices[k] = [
					rot(S[k].q[2], [S[k].w/2, -S[k].h/2]),
					rot(S[k].q[2], [S[k].w/2, S[k].h/2]),
					rot(S[k].q[2], [-S[k].w/2, S[k].h/2]),
					rot(S[k].q[2], [-S[k].w/2, -S[k].h/2])
				];
				vertices[k][4] = vertices[k][0];

				var tmpi = 0; var tmpmax = 0; var s = (k ? -1 : 1);
				for(var i = 0; i < 4; ++i){
					var prod = s*numeric['dot'](enormals[k][i], manifold['n']);
					if(prod > tmpmax){
						tmpmax = prod;
						tmpi = i;
					}
				}

				edge[k] = [
				numeric['+'](S[k].q, vertices[k][tmpi]),
				numeric['+'](S[k].q, vertices[k][tmpi+1])
				];
				N[k] = numeric['*'](
							1/2,
							numeric['+'](vertices[k][tmpi], vertices[k][tmpi+1])
							);

				//identify reference edge as most perpendicular edge
				if(tmpmax > prodref){
					prodref = tmpmax; ref = k;
				}
			}
			inc = (ref ? 0 : 1);

			//console.log('ref: ' + ref + ' inc: ' + inc);
			

			var clipped = [];
			clipped[inc] = edge[inc];
			clipped[ref] = edge[ref];

			//clipping operations:
			//loop through both ends, both sides.
			
			var prt = [inc, ref];
			var ord = [0, 1];

			for(var u = 0; u < 2; ++u){
			for(var v = 0; v < 2; ++v){

			if(numeric['dot'](numeric['-'](edge[prt[0]][ord[0]], edge[prt[1]][ord[1]]),
							  numeric['-'](edge[prt[1]][ord[0]], edge[prt[1]][ord[1]])) < 0){
				clipped[prt[0]][ord[0]] =
				intersect(edge[prt[0]], edge[prt[1]][ord[1]], N[prt[1]]);

				if(numeric['dot'](
					numeric['-'](clipped[prt[0]][ord[0]], edge[prt[1]][ord[0]]),
					N[prt[1]]) > 0){
					clipped[prt[0]][ord[0]] =
					intersect(edge[prt[0]], edge[prt[1]][ord[0]],
							  numeric['-'](edge[prt[1]][ord[1]], edge[prt[1]][ord[0]]));
				}

			}

			ord = [ord[1], ord[0]];	}
			prt = [prt[1], prt[0]];	}

			//assemble return values
			var res = [];

			for(var o = 0; o < 2; ++o){
				res[ord[0]] = {
					'inc': inc,
					'n': manifold['n'],
					'Rinc': rot(-S[inc].q[2],
							numeric['-'](clipped[inc][ord[0]],
										[S[inc].q[0], S[inc].q[1]])),
					'Rref': rot(-S[ref].q[2],
							numeric['-'](clipped[ref][ord[1]],
										[S[ref].q[0], S[ref].q[1]]))
				};
				ord = [ord[1], ord[0]];
			}

			return res;
		}

		function intersect(seg, p, n){
				//where segment(seg) intersects line (p, n)
				var a =	X(numeric['-'](p, seg[1]), n)/X(numeric['-'](seg[0], seg[1]), n);
				return numeric['+'](
						numeric['*'](1-a,seg[1]),
						numeric['*'](a, seg[0])
						);
		}

		function collide(){

			K = [];	klabel = 0;

			for(var i = 0; i < B.length; ++i){
			for(var j = i+1; j < B.length; ++j){
			if(B[i] && B[j]){

					//only check for collisions if not in same group
					if(collision_groups.find(B[i].i) != collision_groups.find(B[j].i)){

						var res = box_to_box(B[i], B[j]);

						if(res === false){ /* no collision */ }
						else {
							//console.log('collision between: ' + i + ' ' + j);
							res.forEach(function(r){
							K[klabel] = new k_constraint(klabel, B[i], B[j], r); ++klabel; 
							});
						}

					}
					

			}
			}}

		}


		var B = []; var blabel = 0; //all bodies
		var C = []; var clabel = 0; //static constraints
		var K = []; var klabel = 0; //collision constraints


		$(document).ready(function(){

			$(document).click(function(e){
			console.log(globalq([e.pageX, e.pageY])); }); //positioncheck

			B[blabel] = new box(blabel, 1e+10, 180, 40, [300, 100, 0], [0, 0, 0]); ++blabel;
			C[clabel] = new anchor_constraint(clabel, B[0]); ++clabel;

			B[blabel] = new box(blabel, 1, 40, 40, [300, 160, 0], [0, 10, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [300, 220, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [300, 280, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [300, 340, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [300, 400, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [330, 430, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [360, 460, 0], [0, 0, 0]); ++blabel;
			//B[blabel] = new box(blabel, 1, 40, 40, [300, 280, 0], [0, 0, 0]); ++blabel;
			//B[blabel] = new box(blabel, 1, 40, 40, [320, 300, 0], [0, 0, 0]); ++blabel;
			C[clabel] = new rev_constraint(clabel, B[5], B[6], [315, 415]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[6], B[7], [345, 445]); ++clabel;

			//window.setInterval(timestep, 30);

		});


		function integrate(){
			B.forEach(function(b){
				//verlet step
				var a = g;
				qnext = numeric['+'](numeric['-'](numeric['*'](2, b.q), b.qprev), numeric['*'](dt*dt, a));
				b.qprev = b.q; b.q = qnext;
			});
		}

		function constrain(){

			for(var i = 0; i < 8; ++i){

			C.forEach(function(c){ c.solve(); });

			}
		}

		function render(){ B.forEach(function(b){ b.sync(); }); }

		function timestep(){

			//position update & constraint step
			integrate();
			constrain();


			collide();
			for(var i = 0; i < 8; ++i){
				K.forEach(function(k){ k.solve(); });
			}

			render();

		}
	</script>
</head>

<body>
	<div id = "W">

	</div>


</body>

</html>
