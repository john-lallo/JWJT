<!DOCTYPE HTML>
<html>
<head>

	<style>
		html, body{
			margin: 0;
			padding: 0;

			color: #999;
			background-color: #111;

			font-family: monospace;
			font-size: 12px;
		}

		#W {
			width: 900px;
			height: 900px;

			margin: 20px auto;
			position: relative;

			border: 1px dashed #999;

			overflow: hidden;
		}

		.box {
			width: 20px;
			height: 20px;
			border: 1px solid #999;

			position: absolute;
		}

	</style>

	<script language = "javascript" src = "numeric.js"></script>
	<script language = "javascript" src = "jquery-2.1.4.min.js"></script>

	<script language = "javascript">

		var E = {
			w: function(){ return $('#W').width(); },
			h: function(){ return $('#W').height(); },
			offsetX: function(){ return $('#W').offset().left },
			offsetY: function(){ return $('#W').offset().top }
		};
		function globalq(q){ return ([q[0]-E.offsetX(), E.w()-q[1]+E.offsetY()]); }



		var dt = 0.1;
		var g = [0, 0, 0];



		var box = function(i, m, w, h, q, v){
			this.i = i; //index

			this.invm = 1/m;
			this.invI = 12/(m*(h*h+w*w));

			this.w = w;	//width
			this.h = h;	//height

			this.q = q; //position
			this.qprev = numeric['-'](q, numeric['*'](v, dt)); //prev position

			this.render(); this.sync();
		}

		box.prototype.render = function(){

			S = '<div id = "B' + this.i + '" class = "box" style = "' +
			'width:' + this.w + 'px; height:' + this.h + 'px;' +
			'left:' + (-this.w/2) + 'px;' +
			'bottom:' + (-this.h/2) + 'px;' +
			'"></div>';

			$('#W').append(S); this.elem = $('#B' + this.i);
		}

		box.prototype.sync = function(){
			this.elem.css({
				'-webkit-transform' : 'translate('
				+ this.q[0] + 'px, '
				+ (-this.q[1]) + 'px) rotate('
				+ (-this.q[2]) + 'rad)'
			});
		}


		//debugg marking function
		var marklabel = 0;
		function mark(q){

			S = '<div id = "mark' + marklabel + '" style = "' +
			'position: absolute; width: 4px; height: 4px; background-color: #fff;' +
			'left: -2px;' +
			'bottom: -2px;' +
			'">' + marklabel + '</div>';

			$('#W').append(S);
			var elem = $('#mark' + marklabel);

			elem.css({
				'-webkit-transform' : 'translate('
				+ q[0] + 'px, '
				+ (-q[1]) + 'px)'
			});
			marklabel++;
		}



		//constraint general
		var constraint = function(i, S){
			this.i = i;	//index
			this.S = S; //member bodies

			/*
			this.W = [];

			for(var i = 0; i < 3*this.S.length; ++i){ this.W[i] = [];
			for(var j = 0; j < 3*this.S.length; ++j){
				this.W[i][j] = 0;
			}}

			for(var i = 0; i < S.length; ++i){
				this.W[3*i][3*i] = S[i].invm;
				this.W[3*i+1][3*i+1] = S[i].invm;
				this.W[3*i+2][3*i+2] = S[i].invI;
			}
			*/
		}
		constraint.prototype.condition = function(){ return true; }
		constraint.prototype.C = function() { return 0;	}
		constraint.prototype.nablaC = function() {

			var nablaC = [];

			var C0 = this.C();
			var epsilon = 1e-6;
			for(var i = 0; i < this.S.length; ++i){
				this.S[i].q[0] += epsilon; nablaC[3*i] = (this.C()-C0)/epsilon; this.S[i].q[0] -= epsilon;
				this.S[i].q[1] += epsilon; nablaC[3*i+1] = (this.C()-C0)/epsilon; this.S[i].q[1] -= epsilon;
				this.S[i].q[2] += epsilon; nablaC[3*i+2] = (this.C()-C0)/epsilon; this.S[i].q[2] -= epsilon;
			}

			return [nablaC];
		}
		constraint.prototype.solve = function(){

			if(this.condition()){
				var nablaC = this.nablaC();
				//var nablaCT = numeric['transpose'](nablaC);
				//var WnablaCT = numeric['dot'](this.W, nablaCT);

				var WnablaCT = [];
				for(var i = 0; i < this.S.length; ++i){
					WnablaCT[3*i] = [nablaC[0][3*i]*this.S[i].invm];
					WnablaCT[3*i+1] = [nablaC[0][3*i+1]*this.S[i].invm];
					WnablaCT[3*i+2] = [nablaC[0][3*i+2]*this.S[i].invI];
				}
				
				var nablaCWnablaCT =
				numeric['dot'](nablaC, WnablaCT);
				
				if(numeric['det'](nablaCWnablaCT) == 0){ return; }

				var lambda = numeric['*'](-this.C(), numeric['inv'](nablaCWnablaCT));
				/*
				numeric['*'](
					numeric['inv'](nablaCWnablaCT), numeric['*'](-1, this.C())
				);
				*/

				var dP = numeric['dot'](WnablaCT, lambda);
				//update positions
				for(var i = 0; i < this.S.length; ++i){
					this.S[i].q = numeric['+'](this.S[i].q, [dP[3*i][0], dP[3*i+1][0], dP[3*i+2][0]]);
				}
			}
		}



		//vector rotation (element form)
		function rot(th, v){
		return ([v[0]*Math.cos(th) - v[1]*Math.sin(th),	v[0]*Math.sin(th) + v[1]*Math.cos(th)]);
		}
		function X(u, v){ return (u[0]*v[1] - u[1]*v[0]); }
		//vector length squared (not used)
		//function L2(v){ return v[0]*v[0]+v[1]*v[1]; }

		//constraint: rev constraint
		function rev_constraint(i, A, B, P){
			constraint.call(this, i, [A, B]);

			this.rA = numeric['-'](P, [this.S[0].q[0], this.S[0].q[1]]);
			this.rA = rot(-this.S[0].q[2], this.rA);

			this.rB = numeric['-'](P, [this.S[1].q[0], this.S[1].q[1]]);
			this.rB = rot(-this.S[1].q[2], this.rB);
		}
		rev_constraint.prototype = Object.create(constraint.prototype);
		rev_constraint.prototype.constructor = rev_constraint;

		rev_constraint.prototype.C = function(){
			var D = numeric['-'](
				numeric['+'](
					[this.S[0].q[0], this.S[0].q[1]],
					rot(this.S[0].q[2], this.rA)
				),
				numeric['+'](
					[this.S[1].q[0], this.S[1].q[1]],
					rot(this.S[1].q[2], this.rB)
				)
			);

			return numeric['dot'](D, D);
		}


		//constraint: anchor constraint
		function anchor_constraint(i, A){
			constraint.call(this, i, [A]);

			this.P = this.S[0].q;
		}
		anchor_constraint.prototype = Object.create(constraint.prototype);
		anchor_constraint.prototype.constructor = anchor_constraint;

		anchor_constraint.prototype.solve = function(){ this.S[0].q = this.P; }



		//constraint: collision constraint
		function k_constraint(i, A, B, contact){
			constraint.call(this, i, [A, B]);
			this.contact = contact;
		}
		k_constraint.prototype = Object.create(constraint.prototype);
		k_constraint.prototype.constructor = k_constraint;

		k_constraint.prototype.solve = function(){
			this.C();
		}

		k_constraint.prototype.C = function(){
			console.log('C');
			var d = [this.S[1].q[0]-this.S[0].q[0], this.S[1].q[1]-this.S[0].q[1]];
			var rA; var rB;
			if(this.contact['inc'] == 0){
				rA = rot(this.S[0].q[2], this.contact['Rinc']);
				rB = numeric['-'](rA, d);

				//mark([this.S[0].q[0]+rA[0], this.S[0].q[1]+rA[1]]);
				//mark([this.S[1].q[0]+rB[0], this.S[1].q[1]+rB[1]]);

			} else {
				rB = rot(this.S[1].q[2], this.contact['Rinc']);
				rA = numeric['+'](d, rB);

				//mark([this.S[0].q[0]+rA[0], this.S[0].q[1]+rA[1]]);
				//mark([this.S[1].q[0]+rB[0], this.S[1].q[1]+rB[1]]);
			}

			console.log(this.contact['n']);
			console.log([(this.S[0].q[0]+rA[0]-this.S[1].q[0]-rB[0]),
			(this.S[0].q[1]+rA[1]-this.S[1].q[1]-rB[1])]);

			return numeric['dot'](
			[(this.S[0].q[0]+rA[0]-this.S[1].q[0]-rB[0]),
			(this.S[0].q[1]+rA[1]-this.S[1].q[1]-rB[1])],
			this.contact['n']
			);
//TBA;
		}







		//collision detection
		function box_to_box(A, B){
			//Separate Axis Thm.
			
			var diagA1 = rot(A.q[2], [A.w/2, A.h/2]);
			var diagA2 = rot(A.q[2], [A.w/2, -A.h/2]);

			var diagB1 = rot(B.q[2], [B.w/2, B.h/2]);
			var diagB2 = rot(B.q[2], [B.w/2, -B.h/2]);

			var d = [B.q[0]-A.q[0], B.q[1]-A.q[1]];

			var axes = [
				rot(A.q[2], [1, 0]),
				rot(A.q[2], [0, 1]),
				rot(B.q[2], [1, 0]),
				rot(B.q[2], [0, 1]),
			];

			var tmp = [];

			tmp['i'] = 0; tmp['n'] = axes[0]; tmp['dL'] = 1e+9;

			for(var i = 0; i < 4; ++i){

				var projA = Math.max(
					Math.abs(numeric['dot'](diagA1, axes[i])),
					Math.abs(numeric['dot'](diagA2, axes[i]))
				);

				var projB = Math.max(
					Math.abs(numeric['dot'](diagB1, axes[i])),
					Math.abs(numeric['dot'](diagB2, axes[i]))
				);

				var projD = Math.abs(numeric['dot'](d, axes[i]));

				var e = projA + projB - projD;
				if(e < 0){ return false; }
				if(e < tmp['dL']){

					tmp['i'] = i;
					tmp['n'] = axes[i];
					tmp['dL'] = e;

					var sign = 1;
					if(numeric['dot'](d, tmp['n']) < 0){ tmp['n'] = numeric['*'](tmp['n'], -1); }
				}
			}

			//contact generations
			var res = generate_contacts(A, B, tmp);
			return res;
		}
		
		//generate contact points from manifold an colliding shapes.
		function generate_contacts(A, B, manifold){

			var S = [A, B];

			//find best colliding edges.
			var edge = [];
			var enormals = [];
			var vertices = [];

			var ref = 0; var inc = 0; var prodref = 0;
			for(var k = 0; k < 2; ++k){

				enormals[k] = [
					rot(S[k].q[2], [1, 0]),
					rot(S[k].q[2], [0, 1]),
					rot(S[k].q[2], [-1, 0]),
					rot(S[k].q[2], [0, -1])
				];

				vertices[k] = [
					rot(S[k].q[2], [S[k].w/2, -S[k].h/2]),
					rot(S[k].q[2], [S[k].w/2, S[k].h/2]),
					rot(S[k].q[2], [-S[k].w/2, S[k].h/2]),
					rot(S[k].q[2], [-S[k].w/2, -S[k].h/2])
				];
				vertices[k][4] = vertices[k][0];

				var tmpi = 0; var tmpmax = 0; var s = (k ? -1 : 1);
				for(var i = 0; i < 4; ++i){
					var prod = s*numeric['dot'](enormals[k][i], manifold['n']);
					if(prod > tmpmax){ tmpmax = prod; tmpi = i; }
				}

				edge[k] = [
				numeric['+'](S[k].q, vertices[k][tmpi]),
				numeric['+'](S[k].q, vertices[k][tmpi+1])
				];

				//identify reference edge as most perpendicular edge
				if(tmpmax > prodref){ prodref = tmpmax; ref = k; }
			}
			inc = (ref ? 0 : 1);

			/*
			mark(edge[ref][0]);
			mark(edge[ref][1]);

			mark(edge[inc][0]);
			mark(edge[inc][1]);
			*/

			console.log('ref: ' + ref + ' inc: ' + inc);

			//clipping
			var flag0 = X(manifold['n'], numeric['-'](edge[inc][0], edge[ref][0]))*
						X(manifold['n'], numeric['-'](edge[inc][1], edge[ref][0]));

			var flag1 = X(manifold['n'], numeric['-'](edge[inc][0], edge[ref][1]))*
						X(manifold['n'], numeric['-'](edge[inc][1], edge[ref][1]));

			if(flag0 < 0){
				//incident edge: opposite sides of 0 limit
				console.log('clip 0');

				var a = X(numeric['-'](edge[ref][0], edge[inc][1]), manifold['n'])/
						X(numeric['-'](edge[inc][0], edge[inc][1]), manifold['n']);

				edge[inc][1] = [
								edge[inc][1][0]*(1-a)+edge[inc][0][0]*a,
								edge[inc][1][1]*(1-a)+edge[inc][0][1]*a
								];
			}

			if(flag1 < 0){
				//incident edge: opposite sides of 1 limit
				console.log('clip 1');
	
				var a = X(numeric['-'](edge[ref][1], edge[inc][1]), manifold['n'])/
						X(numeric['-'](edge[inc][0], edge[inc][1]), manifold['n']);

				edge[inc][0] = [
								edge[inc][1][0]*(1-a)+edge[inc][0][0]*a,
								edge[inc][1][1]*(1-a)+edge[inc][0][1]*a
								];
			}

			//select only penetrating points
			var data = [];
			var cont = 0;
			if(X(
			numeric['-'](edge[ref][1], edge[ref][0]),
			numeric['-'](edge[inc][0], edge[ref][0])) > 0){

				data[cont] = [];

				data[cont]['n'] = manifold['n'];
				data[cont]['P'] = edge[inc][0];
				data[cont]['inc'] = inc;
				data[cont]['Rinc'] =
				rot(-S[inc].q[2], numeric['-'](edge[inc][0], S[inc].q));

				//mark(edge[inc][0]);

				++cont;
			}

			if(X(
			numeric['-'](edge[ref][1], edge[ref][0]),
			numeric['-'](edge[inc][1], edge[ref][0])) > 0){
				data[cont] = [];

				data[cont]['n'] = manifold['n'];
				data[cont]['P'] = edge[inc][1];
				data[cont]['inc'] = inc;
				data[cont]['Rinc'] =
				rot(-S[inc].q[2], numeric['-'](edge[inc][1], S[inc].q));

				//mark(edge[inc][1]);

				++cont;
			}

			
			

			return data;
		}




		function collide(){

			K = [];
			klabel = 0;

			for(var i = 0; i < B.length; ++i){
			for(var j = i+1; j < B.length; ++j){
			if(B[i] && B[j]){

					var res = box_to_box(B[i], B[j]);

					if(res === false){ /* no collision */ }
					else {
						console.log('collision between: ' + i + ' ' + j);
						res.forEach(function(r){

						//mark(r['P']);

						K[klabel] = new k_constraint(klabel, B[i], B[j], r); ++klabel;
						});	
					}
					

			}
			}}

		}


		var B = []; var blabel = 0; //all bodies
		var C = []; var clabel = 0; //static constraints
		var K = []; var klabel = 0; //collision constraints


		$(document).ready(function(){

			$(document).click(function(e){
			console.log(globalq([e.pageX, e.pageY])); }); //positioncheck


			B[blabel] = new box(blabel, 1, 40, 40, [310, 548, 0], [-120, -80, -6]); ++blabel;

			B[blabel] = new box(blabel, 1, 40, 40, [300, 200, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [400, 200, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [300, 300, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [400, 300, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [300, 400, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [400, 400, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 80, 40, [300, 500, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 40, 40, [400, 500, 0], [0, 0, 0]); ++blabel;


			//window.setInterval(timestep, 30);

		});


		function integrate(){
			B.forEach(function(b){
				//verlet step
				var a = g;
				qnext = numeric['+'](numeric['-'](numeric['*'](2, b.q), b.qprev), numeric['*'](dt*dt, a));
				b.qprev = b.q; b.q = qnext;
			});
		}

		function constrain(){

			for(var i = 0; i < 12; ++i){

			C.forEach(function(c){ c.solve(); });

			}
		}

		function velocity_correction(){
			K.forEach(function(k){ /*k.velocity();*/ });
		}

		function render(){ B.forEach(function(b){ b.sync(); }); }

		function timestep(){
			integrate();

			constrain();

			collide();

			//is this supposed to be here?
			K.forEach(function(k){ k.solve(); });


			//velocity_correction();


			render();

		}
	</script>
</head>

<body>
	<div id = "W">

	</div>


</body>

</html>
