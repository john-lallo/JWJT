<!DOCTYPE HTML>
<html>
<head>

	<style>
		html, body{
			margin: 0;
			padding: 0;

			color: #999;
			background-color: #111;
		}

		#W {
			width: 900px;
			height: 900px;

			margin: 20px auto;
			position: relative;

			border: 1px dashed #999;

			overflow: hidden;
		}

		.box {
			width: 20px;
			height: 20px;
			border: 1px solid #999;

			position: absolute;
		}
	</style>

	<script language = "javascript" src = "numeric.js"></script>
	<script language = "javascript" src = "jquery-2.1.4.min.js"></script>

	<script language = "javascript">

		var E = {
			w: function(){ return $('#W').width(); },
			h: function(){ return $('#W').height(); },
			offsetX: function(){ return $('#W').offset().left },
			offsetY: function(){ return $('#W').offset().top }
		};
		function globalq(q){ return ([q[0]-E.offsetX(), E.w()-q[1]+E.offsetY()]); }



		var dt = 0.1;
		var g = [0, -9.8, 0];



		var box = function(i, m, w, h, q, v){
			this.i = i; //index

			this.invm = 1/m;
			this.invI = 12/(m*(h*h+w*w));

			this.w = w;	//width
			this.h = h;	//height

			this.q = q; //position
			this.qprev = numeric['-'](q, numeric['*'](v, dt)); //prev position

			this.render(); this.sync();
		}

		box.prototype.render = function(){

			S = '<div id = "B' + this.i + '" class = "box" style = "' +
			'width:' + this.w + 'px; height:' + this.h + 'px;' +
			'left:' + (-this.w/2) + 'px;' +
			'bottom:' + (-this.h/2) + 'px;' +
			'"></div>';

			$('#W').append(S); this.elem = $('#B' + this.i);
		}

		box.prototype.sync = function(){
			this.elem.css({
				'-webkit-transform' : 'translate('
				+ this.q[0] + 'px, '
				+ (-this.q[1]) + 'px) rotate('
				+ (-this.q[2]) + 'rad)'
			});
		}



		//constraint general
		var constraint = function(i, S){
			this.i = i;	//index
			this.S = S; //member bodies

			/*
			this.W = [];

			for(var i = 0; i < 3*this.S.length; ++i){ this.W[i] = [];
			for(var j = 0; j < 3*this.S.length; ++j){
				this.W[i][j] = 0;
			}}

			for(var i = 0; i < S.length; ++i){
				this.W[3*i][3*i] = S[i].invm;
				this.W[3*i+1][3*i+1] = S[i].invm;
				this.W[3*i+2][3*i+2] = S[i].invI;
			}
			*/
		}
		constraint.prototype.condition = function(){ return true; }
		constraint.prototype.C = function() { return 0;	}
		constraint.prototype.nablaC = function() {

			var nablaC = [];

			var C0 = this.C();
			var epsilon = 1e-6;
			for(var i = 0; i < this.S.length; ++i){
				this.S[i].q[0] += epsilon; nablaC[3*i] = (this.C()-C0)/epsilon; this.S[i].q[0] -= epsilon;
				this.S[i].q[1] += epsilon; nablaC[3*i+1] = (this.C()-C0)/epsilon; this.S[i].q[1] -= epsilon;
				this.S[i].q[2] += epsilon; nablaC[3*i+2] = (this.C()-C0)/epsilon; this.S[i].q[2] -= epsilon;
			}

			return [nablaC];
		}
		constraint.prototype.solve = function(){

			if(this.condition()){
				var nablaC = this.nablaC();
				//var nablaCT = numeric['transpose'](nablaC);
				//var WnablaCT = numeric['dot'](this.W, nablaCT);

				var WnablaCT = [];
				for(var i = 0; i < this.S.length; ++i){
					WnablaCT[3*i] = [nablaC[0][3*i]*this.S[i].invm];
					WnablaCT[3*i+1] = [nablaC[0][3*i+1]*this.S[i].invm];
					WnablaCT[3*i+2] = [nablaC[0][3*i+2]*this.S[i].invI];
				}
				
				var nablaCWnablaCT =
				numeric['dot'](nablaC, WnablaCT);
				
				if(numeric['det'](nablaCWnablaCT) == 0){ return; }

				var lambda = numeric['*'](-this.C(), numeric['inv'](nablaCWnablaCT));
				/*
				numeric['*'](
					numeric['inv'](nablaCWnablaCT), numeric['*'](-1, this.C())
				);
				*/

				var dP = numeric['dot'](WnablaCT, lambda);
				//update positions
				for(var i = 0; i < this.S.length; ++i){
					this.S[i].q = numeric['+'](this.S[i].q, [dP[3*i][0], dP[3*i+1][0], dP[3*i+2][0]]);
				}
			}
		}



		//vector rotation (element form)
		function rot(th, v){
		return ([v[0]*Math.cos(th) + v[1]*Math.sin(th),	v[0]*Math.sin(th) - v[1]*Math.cos(th)]);
		}
		//vector length squared (not used)
		//function L2(v){ return v[0]*v[0]+v[1]*v[1]; }

		//constraint: rev constraint
		function rev_constraint(i, A, B, P){
			constraint.call(this, i, [A, B]);

			this.rA = numeric['-'](P, [this.S[0].q[0], this.S[0].q[1]]);
			this.rA = rot(-this.S[0].q[2], this.rA);

			this.rB = numeric['-'](P, [this.S[1].q[0], this.S[1].q[1]]);
			this.rB = rot(-this.S[1].q[2], this.rB);
		}
		rev_constraint.prototype = Object.create(constraint.prototype);
		rev_constraint.prototype.constructor = rev_constraint;

		rev_constraint.prototype.C = function(){
			var D = numeric['-'](
				numeric['+'](
					[this.S[0].q[0], this.S[0].q[1]],
					rot(this.S[0].q[2], this.rA)
				),
				numeric['+'](
					[this.S[1].q[0], this.S[1].q[1]],
					rot(this.S[1].q[2], this.rB)
				)
			);

			return numeric['dot'](D, D);
		}


		//constraint: anchor constraint
		function anchor_constraint(i, A){
			constraint.call(this, i, [A]);

			this.P = this.S[0].q;
		}
		anchor_constraint.prototype = Object.create(constraint.prototype);
		anchor_constraint.prototype.constructor = anchor_constraint;

		anchor_constraint.prototype.solve = function(){ this.S[0].q = this.P; }



		//constraint: collision constraint
		function k_constraint(i, A, B, manifold){

			constraint.call(this, i, [A, B]);

			this.manifold = manifold; //unit penetration vector

			this.targL = 
			Math.abs(numeric['dot'](
				[this.S[1].q[0]-this.S[0].q[0], this.S[1].q[1]-this.S[0].q[1]],
				this.manifold['n']
			)) + this.manifold['dL']; //target distance.

		}
		k_constraint.prototype = Object.create(constraint.prototype);
		k_constraint.prototype.constructor = k_constraint;

		k_constraint.prototype.C = function(){
			
			var L = [this.S[1].q[0]-this.S[0].q[0], this.S[1].q[1]-this.S[0].q[1]];

			return (Math.abs(numeric['dot'](L, this.manifold['n'])) - this.targL);
		}

		//velocity correction step
		k_constraint.prototype.velocity = function(){

			console.log(this.manifold['n']);

			var v0A = [
			(this.S[0].q[0]-this.S[0].qprev[0])/dt,
			(this.S[0].q[1]-this.S[0].qprev[1])/dt
			];

			var v0B = [
			(this.S[1].q[0]-this.S[1].qprev[0])/dt,
			(this.S[1].q[1]-this.S[1].qprev[1])/dt
			];

			var w0A = (this.S[0].q[2]-this.S[0].qprev[2])/dt;
			var w0B = (this.S[1].q[2]-this.S[1].qprev[2])/dt;

			var e = 1;

			var vAB = numeric['-'](v0A, v0B);
			var d = [this.S[1].q[0]-this.S[0].q[0], this.S[1].q[1]-this.S[0].q[1]];

			var rA = [0, 0];
			var rB = [0, 0];

			console.log('manifold i:' + this.manifold['i']);
			if(this.manifold['i'] < 2){
				//reference on A, calculate rA rB from B
				/*
				var Bvertices = [
					rot(this.S[1].q[2], [this.S[1].w/2, this.S[1].h/2]),
					rot(this.S[1].q[2], [-this.S[1].w/2, this.S[1].h/2]),
					rot(this.S[1].q[2], [-this.S[1].w/2, -this.S[1].h/2]),
					rot(this.S[1].q[2], [this.S[1].w/2, -this.S[1].h/2])
				];

				console.log('vertices:');
				console.log(Bvertices);

				var maxdot = 0; var maxi = 0;
				var dot = 0;				
				for(var i = 0; i < 4; ++i){
					dot = -numeric['dot'](Bvertices[i], this.manifold['n']);
					if(dot > maxdot){ maxdot = dot; maxi = i; }
				}

				rB = Bvertices[maxi];
				rA = numeric['+'](d, rB);

				console.log('rA:');
				console.log(rA);

				console.log('rB:');
				console.log(rB);
				*/
			} else {
				//reference on B, calculate rA rB from A

				var Avertices = [
					rot(this.S[0].q[2], [this.S[0].w/2, this.S[0].h/2]),
					rot(this.S[0].q[2], [-this.S[0].w/2, this.S[0].h/2]),
					rot(this.S[0].q[2], [-this.S[0].w/2, -this.S[0].h/2]),
					rot(this.S[0].q[2], [this.S[0].w/2, -this.S[0].h/2])
				];

				console.log('vertices:');
				console.log(Avertices);

				var maxdot = 0; var maxi = 0;
				var dot = 0;				
				for(var i = 0; i < 4; ++i){
					dot = numeric['dot'](Avertices[i], this.manifold['n']);
					if(dot > maxdot){ maxdot = dot; maxi = i; }
				}

				rA = Avertices[maxi];
				rB = numeric['-'](d, rA);

				console.log('rA:');
				console.log(rA);

				console.log('rB:');
				console.log(rB);

			}




			

			var numer = -(1+e)*numeric['dot'](vAB, this.manifold['n']);

			var rAdotN = numeric['dot'](rA, this.manifold['n']);
			var rBdotN = numeric['dot'](rB, this.manifold['n']);

			var denum = (
			(this.S[0].invm+this.S[1].invm) +
			rAdotN*rAdotN/this.S[0].invm +
			rBdotN*rBdotN/this.S[1].invm
			);

			var j = numer/denum;

			var J = 
			[
				j*this.manifold['n'][0]/dt,
				j*this.manifold['n'][1]/dt,
				0,
			];

			
			console.log('J:');
			console.log(J);


			this.S[0].qprev = numeric['-'](this.S[0].q,
				numeric['+'](numeric['*']([v0A[0], v0A[1], w0A], dt), J)
			);

			console.log(this.S[0]);

			this.S[1].qprev = numeric['-'](this.S[1].q,
				numeric['-'](numeric['*']([v0B[0], v0B[1], w0B], dt), J)
			);
			
		}


		//collision detection
		function box_to_box(A, B){
			//Separate Axis Thm.
			

			var diagA1 = rot(A.q[2], [A.w/2, A.h/2]);
			var diagA2 = rot(A.q[2], [A.w/2, -A.h/2]);

			var diagB1 = rot(B.q[2], [B.w/2, B.h/2]);
			var diagB2 = rot(B.q[2], [B.w/2, -B.h/2]);

			var d = [B.q[0]-A.q[0], B.q[1]-A.q[1]];

			var axes = [
				rot(A.q[2], [1, 0]),
				rot(A.q[2], [0, 1]),
				rot(B.q[2], [1, 0]),
				rot(B.q[2], [0, 1]),
			];

			var tmp = [];

			tmp['i'] = 0;
			tmp['n'] = axes[0];
			tmp['dL'] = 1e+9;

			for(var i = 0; i < 4; ++i){

				var projA = Math.max(
					Math.abs(numeric['dot'](diagA1, axes[i])),
					Math.abs(numeric['dot'](diagA2, axes[i]))
				);

				var projB = Math.max(
					Math.abs(numeric['dot'](diagB1, axes[i])),
					Math.abs(numeric['dot'](diagB2, axes[i]))
				);

				var projD = Math.abs(numeric['dot'](d, axes[i]));

				/*
				console.log('a:' + projA);
				console.log('b:' + projB);
				console.log('d:' + projD);
				*/

				var e = projA + projB - projD;
				if(e < 0){ return false; }
				if(e < tmp['dL']){

					tmp['i'] = i;
					tmp['n'] = axes[i];
					tmp['dL'] = e;

					var sign = 1;
					if(numeric['dot'](d, tmp['n']) < 0){ tmp['n'] = numeric['*'](tmp['n'], -1); }

					/* THIS IS VERY INCORRECT */
					//tmp['rA'] = numeric['*']( sign * projA, tmp['n']);
					//tmp['rB'] = numeric['*'](-sign * projB, tmp['n']);
				}
			}


			console.log('bleuuuurgh');

			return tmp;
		}

		function collide(){

			K = [];
			klabel = 0;

			for(var i = 0; i < B.length; ++i){
			for(var j = i+1; j < B.length; ++j){
			if(B[i] && B[j]){

					var k = box_to_box(B[i], B[j]);

					if(k){
						K[klabel] = new k_constraint(klabel, B[i], B[j], k); ++klabel;
					}

			}
			}}

			K.forEach(function(k){ k.solve(); });
		}


		var B = []; var blabel = 0; //all bodies
		var C = []; var clabel = 0; //static constraints
		var K = []; var klabel = 0; //collision constraints

		/*
		function demo_hinges(){

			var Blab0 = blabel;

			B[blabel] = new box(blabel, 1, 130, 10, [300, 300, 0], [10, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 10, 130, [360, 360, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 130, 10, [300, 420, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 10, 130, [240, 360, 0], [0, 0, 0]); ++blabel;


			C[clabel] = new anchor_constraint(clabel, B[Blab0+2]); ++clabel;

			C[clabel] = new rev_constraint(clabel, B[Blab0+0], B[Blab0+1], [360, 300]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[Blab0+1], B[Blab0+2], [360, 420]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[Blab0+2], B[Blab0+3], [240, 420]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[Blab0+3], B[Blab0+0], [240, 300]); ++clabel;
		}

		function demo_chain(){
			var Blab0 = blabel;

			B[blabel] = new box(blabel, 1, 10, 70, [600, 600, 0], [0, 0, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 10, 70, [600, 540, 0], [20, 0, 0.2]); ++blabel;
			B[blabel] = new box(blabel, 1, 10, 70, [600, 480, 0], [40, 0, 0.4]); ++blabel;
			B[blabel] = new box(blabel, 1, 10, 70, [600, 420, 0], [60, 0, 0.6]); ++blabel;
			B[blabel] = new box(blabel, 1, 10, 70, [600, 360, 0], [80, 0, 0.8]); ++blabel;

			C[clabel] = new anchor_constraint(clabel, B[Blab0+0]); ++clabel;

			C[clabel] = new rev_constraint(clabel, B[Blab0+0], B[Blab0+1], [600, 570]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[Blab0+1], B[Blab0+2], [600, 510]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[Blab0+2], B[Blab0+3], [600, 450]); ++clabel;
			C[clabel] = new rev_constraint(clabel, B[Blab0+3], B[Blab0+4], [600, 390]); ++clabel;
		}
		*/

		$(document).ready(function(){

			$(document).click(function(e){
			console.log(globalq([e.pageX, e.pageY])); }); //positioncheck


			//demo_chain();


			B[blabel] = new box(blabel, 1, 40, 40, [300, 300, 0.1], [80, 80, 0]); ++blabel;
			B[blabel] = new box(blabel, 1, 60, 60, [500, 300, 0], [0, 80, 0]); ++blabel;



			//window.setInterval(timestep, 30);

		});


		function integrate(){
			B.forEach(function(b){
				//verlet step
				var a = g;
				qnext = numeric['+'](numeric['-'](numeric['*'](2, b.q), b.qprev), numeric['*'](dt*dt, a));
				b.qprev = b.q; b.q = qnext;
			});
		}

		function constrain(){

			for(var i = 0; i < 12; ++i){

			C.forEach(function(c){ c.solve(); });

			}
		}

		function velocity_correction(){
			K.forEach(function(k){ k.velocity(); });
		}

		function render(){ B.forEach(function(b){ b.sync(); }); }

		function timestep(){
			integrate();
			constrain();

			collide();

			velocity_correction();

			render();
		}
	</script>
</head>

<body>
	<div id = "W">

	</div>


</body>

</html>
